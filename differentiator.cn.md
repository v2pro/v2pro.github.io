* TOC
{:toc}

# 总体思路

没有必要重新造重复的轮子，那是在浪费生命。

* 基础组件：大部分轮子都要把用户绑死在一个实现上。我们需要一个中间层，通过 interface 提供 API 给直接用户，提供 SPI 做为扩展点给其他的库作者。让业务和具体的轮子解耦，使得业务逻辑可以方便迁移。通过 SPI 让轮子之间的互相组合成为可能。
* 业务平台：在线业务的微服务可以分成“存储”，“流程”和“智能”三类。提供平台使得三类微服务共性的部分可以下沉，使得写业务的同学可以专注于业务逻辑本身。
* 进程外流量监控和回放：对于遗留应用，改代码的成本是非常高的。通过在网络层分析流量，可以快速给遗留应用提供质量保证手段。

# 基础组件

## 反射

### Accessor

把对象分为以下几类：

* 简单值
* Struct
* Map
* Array
* Variant

提供抽象的反射接口对这些对象进行读和写。这些对象底层可以是

* go 语言的对象
* http request/response
* json []byte
* thrift []byte
* mysql protocol []byte
* redis protocol []byte

Accessor提供的能力可分为（类似 STL 的 iterator）：

* 顺序读
* 随机读
* 顺序写
* 随机写

### Copy

所有的协议编解码都可以抽象为以下几类对象的通过Accessor实现互相拷贝。当然代码里如果有对象互相拷贝的需求，深拷贝一个对象的需求，也可以使用 Copy：

* map 顺序读 => struct 随机写（比如json绑定到struct）
* struct 顺序读 => struct 随机写 （mysql协议等有schema的协议解析过程，原始的[]byte读的时候，无法做基于offset的随机定位）
* struct 顺序读 => map 顺序写 （struct的json序列化）
* 其他同类型对象的拷贝 （简单赋值）

在拷贝的过程中，如果有类型不符等场景，可以提供 SPI 去做 Accessor 的包装。比如把一个 int 类型的 accessor 转换为 string 类型的 accessor。这样，无论是什么协议的编解码，都可以用统一的方式来做外部扩展。

### Validate

所有的参数验证都可以抽象为对象图的遍历。通过 Accessor 接口，我们可以很容易遍历任意输入。

### 函数式 Util

# 业务平台

# 进程外流量监控和回放
